package com.example.microservicesbackend.service;

import com.bloxbean.cardano.client.cip.cip30.CIP30DataSigner;
import com.bloxbean.cardano.client.cip.cip30.DataSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Base64;
import java.util.Date;
import java.util.Optional;

@Service
public class AuthService {

    private static final Logger logger = LoggerFactory.getLogger(AuthService.class);

    private static final String ADA_HANDLE_PREFIX = "ada_handle:";
    private static final String PCS_POLICY_IDS_PREFIX = "pcs:";

    /**
     * (Optional) Extracts the ADA handle from the provided nonce if present.
     *
     * @param nonce The nonce string.
     * @return An Optional containing the ADA handle, or empty if not found.
     */
    private Optional<String> extractAdaHandleFromNonce(String nonce) {
        try {
            return Optional.ofNullable(nonce)
                    .map(n -> n.split(";"))
                    .stream()
                    .flatMap(Arrays::stream)
                    .filter(part -> part.trim().startsWith(ADA_HANDLE_PREFIX))
                    .map(part -> part.substring(ADA_HANDLE_PREFIX.length()))
                    .findFirst();
        } catch (Exception e) {
            logger.error("Error extracting ADA handle from nonce: {}", e.getMessage());
            return Optional.empty();
        }
    }

    /**
     * (Optional) Extracts the PCS policy IDs from the provided nonce if present.
     *
     * @param nonce The nonce string.
     * @return An Optional containing the PCS policy IDs, or empty if not found.
     */
    private Optional<String> extractPcsPolicyIdsFromNonce(String nonce) {
        try {
            return Optional.ofNullable(nonce)
                    .map(n -> n.split(";"))
                    .stream()
                    .flatMap(Arrays::stream)
                    .filter(part -> part.trim().startsWith(PCS_POLICY_IDS_PREFIX))
                    .map(part -> part.substring(PCS_POLICY_IDS_PREFIX.length()))
                    .findFirst();
        } catch (Exception e) {
            logger.error("Error extracting PCS policy IDs from nonce: {}", e.getMessage());
            return Optional.empty();
        }
    }

    /**
     * Verifies the data signature using CIP-30 and validates the nonce payload.
     *
     * @param loginSignature The data signature from the wallet.
     * @param nonce          The expected nonce tied to the wallet address.
     * @return True if the signature and nonce are valid; false otherwise.
     */
    public boolean verifySignature(DataSignature loginSignature, String nonce) {
        try {
            boolean isValidSignature = CIP30DataSigner.INSTANCE.verify(loginSignature);
            if (!isValidSignature) {
                logger.error("Signature verification failed.");
                return false;
            }
            String payload = new String(loginSignature.coseSign1().payload());
            if (!nonce.equals(payload)) {
                logger.error("Nonce does not match payload. Expected: {}, Actual: {}", nonce, payload);
                return false;
            }
            return true;
        } catch (Exception e) {
            logger.error("Error verifying signature: {}", e.getMessage(), e);
            return false;
        }
    }

    /**
     * Creates a Decentralized Digital Identity (DID) token for the authenticated user.
     * The token is generated by computing the SHA-256 hash of the base address and encoding it in URL-safe Base64,
     * then prefixing it with "did:cardano:".
     *
     * @param baseAddress The base address of the user.
     * @return An Optional containing the DID token if successful, or empty if an error occurs.
     */
    public Optional<String> createDidToken(String baseAddress) {
        try {
            // Compute the SHA-256 hash of the base address
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(baseAddress.getBytes());
            // Encode the hash using URL-safe Base64 without padding
            String encoded = Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
            String didToken = "did:cardano:" + encoded;
            logger.info("Generated DID token for address: {}", baseAddress);
            return Optional.of(didToken);
        } catch (Exception e) {
            logger.error("Error generating DID token: {}", e.getMessage(), e);
            return Optional.empty();
        }
    }
}
